<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    Simone
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="life,code" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg_blue.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.2.0"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">Simone</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/tech/" title="Technique">
		                Technique
		            </a>
		        </li>
		        
		        <li>
		            <a href="/jour/" title="Journal">
		                Journal
		            </a>
		        </li>
		        
		        <li>
		            <a href="/language/" title="Learn">
		                Learn
		            </a>
		        </li>
		        
		        <li>
		            <a href="/interested/" title="Interested">
		                Interested
		            </a>
		        </li>
		        
		        <li>
		            <a href="/photo/" title="Photo Wall">
		                Photo Wall
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/SimoneJie" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            
            <!-- Post -->
            <div class="typo" style="padding: 3rem; position: relative;">
                <h1 id="dynamic-programming">Dynamic Programming</h1>
<hr>
<h4 id="section">001.</h4>
<p>日期：24/12/30</p>
<p>题目链接：<a target="_blank" rel="noopener" href="https://www.marscode.cn/practice/5www4lxd2k60le?problem_id=7424418560665108524">卡牌翻面求和问题 - MarsCode</a></p>
<p>题目内容：</p>
<p>​ 小M有 <em>n</em> 张卡牌，每张卡牌的正反面分别写着不同的数字，正面是 <span class="math inline">\(a_i\)</span>，背面是<span class="math inline">\(b_i\)</span>。小M希望通过选择<mark>每张卡牌</mark>的一面，使得所有向上的数字之和可以被3整除。你需要告诉小M，一共有多少种不同的方案可以满足这个条件。由于可能的方案数量过大，结果需要对 <span class="math inline">\(10^9+7\)</span>取模。</p>
<p>​ 例如：如果有3张卡牌，正反面数字分别为 <code>(1,2)</code>，<code>(2,3)</code> 和 <code>(3,2)</code>，你需要找到所有满足这3张卡牌正面或背面朝上的数字之和可以被3整除的组合数。</p>
<p>思考：后续卡牌可沿用前面的组合，即状态推导。此外需要遍历每一种组合，适合打表。所以选用动态规划。</p>
<ol type="1">
<li><p>dp数组：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]: i 是第i张牌，j是选到第i张牌后的取余结果(0，1，2三种), </span><br><span class="line">dp[i][(j+num)<span class="comment">%3]（num为当前数字）是取余结果为(j+num)%3的个数 += 本来取余结果为 j 个数【在这一步转变为了(j+num)%3】</span></span><br><span class="line">最终dp[n][0]为选完n张牌后最终取余结果为0的个数</span><br></pre></td></tr></table></figure></li>
<li><p>状态转移方程： <span class="math display">\[
dp[i][(j + a[i]/b[i]) \% 3] =  \left\{
\begin{array}{rcl}
 1   &amp;  &amp; {i = 0   \space and \space   j = 0} \\
 0  &amp; &amp;{i = 0   \space and \space   j = 1 \space or \space 2}\\
 dp[i][(j+a[i]/b[i])\%3] + dp[i-1][j]  &amp; &amp; {i \space &gt; \space 0}
\end{array}
\right.
\]</span> <mark>重点: 最后一步j为0才行，因此前面的每一步就是不断统计取余3后各自为0，1，2的结果</mark></p></li>
<li><p>完整代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int solution(int n, std::vector&lt;int&gt; a, std::vector&lt;int&gt; b) &#123;</span><br><span class="line">    long long mod = 1e9 + 7;</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; dp(n+1, vector&lt;int&gt;(3, 0)); // 全部初始化为0</span><br><span class="line">    dp[0][0] = 1; // 没有card时取余为0，算1种情况</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j = 0; j &lt;= 2; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][(j+a[i-1]) % 3] = (dp[i][(j+a[i-1]) % 3] + dp[i-1][j]) % mod ;</span><br><span class="line">            dp[i][(j+b[i-1]) % 3] = (dp[i][(j+a[i-1]) % 3] + dp[i-1][j]) % mod;</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;             </span><br><span class="line"></span><br><span class="line">    return dp[n][0]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; (solution(3, &#123;1, 2, 3&#125;, &#123;2, 3, 2&#125;) == 3) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; (solution(4, &#123;3, 1, 2, 4&#125;, &#123;1, 2, 3, 1&#125;) == 6) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; (solution(5, &#123;1, 2, 3, 4, 5&#125;, &#123;1, 2, 3, 4, 5&#125;) == 32) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">一开始做题时想错，发现了另一个小小不同的过程方法：</span><br><span class="line">for(int i = 1; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for(int j = 0; j &lt;= 2; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][(j+a[i-1]) % 3] = (dp[i-1][j]) % mod ;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j = 0; j &lt;= 2; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][(j+b[i-1]) % 3] = (dp[i-1][j] +  dp[i][(j+b[i-1]) % 3]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="section-1">002.</h4>
<p>日期：25/01/02</p>
<p>os：一打眼，不会做。。。看题解。。。又是动态规划</p>
<p>题目链接：<a target="_blank" rel="noopener" href="https://www.marscode.cn/practice/5www4lxd2k60le?problem_id=7414004855075225644">MarsCode</a></p>
<p>题目内容：</p>
<p>小R正在研究DNA序列，他需要一个函数来计算将一个受损DNA序列（dna1）转换成一个未受损序列（dna2）所需的最少编辑步骤。编辑步骤包括：增加一个碱基、删除一个碱基或替换一个碱基。</p>
<p>分析：有最优子结构的性质，可以分解为将 <code>dna1</code> 的前 <code>i</code> 个字符转换为 <code>dna2</code> 的前 <code>j</code> 个字符所需的最少编辑步骤的子问题。</p>
<ol type="1">
<li>状态转移方程</li>
</ol>
<p><span class="math display">\[
dp[i][j] =  
\left
\{\begin{array}{rcl} 
dp[i-1][j-1]   &amp;  &amp; {dna[i-1] = dna[j-1]  } \\ 
dp[i][j-1] + 1 &amp; &amp;{ 增加}\\ 
dp[i-1][j] + 1 &amp; &amp;{删除} \\ 
dp[i-1][j-1] + 1 &amp; &amp;{替换}
\end{array}
\right.
\]</span></p>
<ol start="2" type="1">
<li><p>完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">int solution(std::string dna1, std::string dna2) &#123;</span><br><span class="line">    int m = dna1.size();</span><br><span class="line">    int n = dna2.size();</span><br><span class="line">    </span><br><span class="line">    // 创建一个 (m+1) x (n+1) 的二维数组 dp</span><br><span class="line">    std::vector&lt;std::vector&lt;int&gt;&gt; dp(m + 1, std::vector&lt;int&gt;(n + 1, 0));</span><br><span class="line">    </span><br><span class="line">    // 初始化 dp 数组的第一行和第一列</span><br><span class="line">    for (int i = 0; i &lt;= m; ++i) &#123;</span><br><span class="line">        dp[i][0] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int j = 0; j &lt;= n; ++j) &#123;</span><br><span class="line">        dp[0][j] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 填充 dp 数组</span><br><span class="line">    for (int i = 1; i &lt;= m; ++i) &#123;</span><br><span class="line">        for (int j = 1; j &lt;= n; ++j) &#123;</span><br><span class="line">            if (dna1[i-1] == dna2[j-1]) &#123;</span><br><span class="line">                dp[i][j] = dp[i-1][j-1];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j] = std::min(&#123;dp[i-1][j], dp[i][j-1], dp[i-1][j-1]&#125;) + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::cout &lt;&lt; (solution(&quot;AGCTTAGC&quot;, &quot;AGCTAGCT&quot;) == 2) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; (solution(&quot;AGCCGAGC&quot;, &quot;GCTAGCT&quot;) == 4) &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ps: 据说这是一个经典的<strong>编辑距离</strong>问题，也称为<strong>Levenshtein距离</strong>。</p></li>
</ol>

                
                <div class="post-date" style="position: absolute; top: 10px; right: 10px; font-size: 14px; color: #888; background-color: rgba(255, 255, 255, 0.7); padding: 5px; border-radius: 5px;">
                    2025-01-03
                
                </div>     
            </div>
                     

           

        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <!-- <li>Design: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li> -->
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
